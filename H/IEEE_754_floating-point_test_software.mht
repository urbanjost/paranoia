From: <Saved by Windows Internet Explorer 7>
Subject: IEEE 754 floating-point test software
Date: Sun, 13 Mar 2011 20:25:30 -0400
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_00DE_01CBE1BC.CC243FA0"
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.5931

This is a multi-part message in MIME format.

------=_NextPart_000_00DE_01CBE1BC.CC243FA0
Content-Type: text/html;
	charset="Windows-1252"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.math.utah.edu/~beebe/software/ieee/

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- -*-html-*- --><!-- Prettyprinted by html-pretty flex version 1.01 =
[25-Aug-2001] --><!-- on Wed Nov 28 18:06:48 2001 --><!-- for Nelson H. =
F. Beebe (beebe@wasatch.math.utah.edu) --><HTML><HEAD><TITLE>IEEE 754 =
floating-point test software</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Dwindows-1252"><LINK=20
rev=3Dmade href=3D"mailto:beebe@math.utah.edu">
<META content=3D"MSHTML 6.00.6000.17095" name=3DGENERATOR></HEAD>
<BODY><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D--><!-- -*-html-*- -->
<DIV align=3Dright><!-- SiteSearch Google -->
<FORM action=3Dhttp://www.google.com/search method=3Dget><INPUT =
maxLength=3D255=20
size=3D21 name=3Dq> <INPUT type=3Dsubmit value=3DSearch name=3DbtnG> =
<IMG alt=3Dnew2=20
src=3D"http://www.math.utah.edu/images/new2.gif" align=3Dmiddle> <IMG =
alt=3Dnew2=20
src=3D"http://www.math.utah.edu/images/new2.gif" align=3Dmiddle> <FONT=20
size=3D-2><INPUT type=3Dhidden name=3Ddummy> <BR><INPUT type=3Dradio =
value=3D""=20
name=3Dsitesearch> WWW <INPUT type=3Dradio CHECKED=20
value=3Dinurl:www.math.utah.edu/~beebe name=3Dhq>=20
http://www.math.utah.edu/~beebe<BR></FONT></FORM><!-- SiteSearch Google =
--></DIV>
<H1><A name=3Dtop>IEEE 754 floating-point test software </A></H1>
<P>Original version: <B><FONT color=3D#ff0000>Tue Oct 15 01:27:09 2002=20
</FONT></B><BR>Last updates: <B><FONT color=3D#ff0000>Fri Dec 06 =
01:09:08=20
2002&nbsp;&nbsp;&nbsp; Wed May 19 15:59:53 2004&nbsp;&nbsp;&nbsp; Fri =
Nov 12=20
15:50:09 2004&nbsp;&nbsp;&nbsp; Fri May 20 08:32:25 =
2005&nbsp;&nbsp;&nbsp; Mon=20
Jul 9 14:26:05 2007 </FONT></B></P><!--=0A=
            <P>=0A=
                <IMG SRC=3D"images/under-construction.gif">=0A=
                <FONT COLOR=3D"#ff0000">=0A=
                    <B>WARNING WARNING WARNING WARNING WARNING =
WARNING</B><BR>=0A=
                    This document, and the file directory in which it =
resides,=0A=
                    is under active construction, and has not been=0A=
                    officially announced.  Its contents may be subject to=0A=
                    radical changes for a while.=0A=
                </FONT>=0A=
            </P>=0A=
        -->
<BLOCKQUOTE>
  <TABLE border=3D10>
    <TBODY>
    <TR>
      <TD>
        <CENTER><FONT color=3D#ff0000>Comments, and reports of errata or =
bugs,=20
        extensions, and ports to new programming languages and machine=20
        platforms, are welcome via e-mail to the author,<BR><EM>Nelson =
H. F.=20
        Beebe <A=20
        =
href=3D"mailto:beebe@math.utah.edu">&lt;beebe@math.utah.edu&gt;.<BR></A><=
/EM>In=20
        your report, please supply the full document URL, and the =
<EM>title</EM>=20
        and <EM>Last update</EM> time stamp recorded near the top of the =

        document. =
</FONT></CENTER></TD></TR></TBODY></TABLE></BLOCKQUOTE><!--=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D-->
<HR>

<H1><A name=3Dtoc>Table of contents </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#bibliography">Last=
=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#introduction">Next=
=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>Original version: <B><FONT color=3D#ff0000>Wed Nov 28 18:06:48 2001=20
</FONT></B><BR>Last update: <B><FONT color=3D#ff0000>Fri May 20 08:32:37 =
2005=20
</FONT></B></P>
<UL>
  <LI><A=20
  =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#introduction">Intr=
oduction=20
  </A>
  <LI><A =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#whats-new">What's =

  new? </A>
  <LI><A =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#license">License=20
  issues </A>
  <LI><A=20
  =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#testing-is-necessa=
ry">Why=20
  testing is necessary </A>
  <LI><A=20
  =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#ieee-754-soft">IEE=
E 754=20
  in software </A>
  <LI><A=20
  =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#c-with-fortran">Us=
ing=20
  C/C++ and Fortran together </A>
  <LI><A=20
  =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#fortran-notes">Not=
es on=20
  Fortran programs </A>
  <LI><A =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#c-notes">Notes on =

  C/C++ programs </A>
  <LI><A =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#java-notes">Notes =

  on Java programs </A>
  <LI><A =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#maple-notes">Notes=
=20
  on Maple programs </A>
  <LI><A =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#caveats">Caveats=20
  </A>
  <LI><A =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#catalog">Catalog=20
  of programs </A>
  <LI><A =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#futures">Future=20
  directions </A>
  <LI><A =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#other">Other test =

  packages </A>
  <LI><A=20
  =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#bibliography">Bibl=
iography=20
  =
</A></LI></UL><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dintroduction>Introduction </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#toc">Previous=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#whats-new">Next=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>This directory contains a small collection of test programs for =
examining the=20
behavior of IEEE 754 floating-point arithmetic, together with test input =
and=20
output files. There are also a few additional test programs for other =
data=20
types. </P>
<P>Unless otherwise noted below, all of these programs were written by =
Nelson H.=20
F. Beebe, at the Department of Mathematics, University of Utah, Salt =
Lake City,=20
Utah, USA. </P>
<P>The programs were developed over the course of several years, for =
teaching=20
floating-point arithmetic, for testing compilers and programming =
languages, and=20
for surveying prior art, as part of my small contributions to the =
ongoing work=20
(2000--) on the revision of the <EM>IEEE 754 Standard for Binary =
Floating-Point=20
Arithmetic</EM>. </P>
<P>Most of these programs are quite simple, and took only a few minutes =
to=20
write, usually in either Fortran or C, and were often then manually =
translated=20
to the other language, and sometimes, to Java and other programming =
languages.=20
Thanks to manual translation, none of these programs require any =
additional=20
nonstandard header files or support libraries. =
</P><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dwhats-new>What's new? </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#introduction">Prev=
ious=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#license">Next=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>A complete <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/ls-lR.html">alphabe=
tical=20
contents listing </A>as a UNIX <TT>ls -lR</TT> recursive long directory =
listing=20
summarizes what is here, and the companion <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/ls-lRt.html">revers=
e-time=20
ordered contents listing </A>from a UNIX <TT>ls -lRt</TT> command =
readily shows=20
what is new. </P>
<P>See the <A name=3D#archive-formats>archive section </A>of the catalog =
below for=20
information on retrieving the entire collection. =
</P><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dlicense>License issues </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#whats-new">Previou=
s=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#ieee-754-soft">Nex=
t=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>It has been a great tradition in the numerical linear algebra =
community for=20
more than 30 years of freely sharing software without patents or =
copyright=20
claims, for free and unrestricted use by anyone. </P>
<P>Sadly, commercialism and lawyers have gotten involved in software, =
and the=20
view of many people in the open source community today is that even=20
freely-distributable software must be protected by a license that =
guarantees you=20
the right to use the software, and to further distribute it. </P>
<P>For the software and documentation in this directory that is written =
by me,=20
Nelson H. F. Beebe <A=20
href=3D"mailto:beebe@math.utah.edu"><TT>&lt;beebe@math.utah.edu&gt;</TT> =
</A>I=20
therefore choose to place this material under the <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/COPYING"><EM>GNU =
General=20
Public License.</EM> </A></P>
<P>Other code here that is credited to others may contain copyright =
claims which=20
should be honored in further distributions. In the absence of explicit =
copyright=20
statements in such code, you may assume that the original authors =
intended that=20
their work could be freely distributed, in the historical tradition. =
</P><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dieee-754-soft>IEEE 754 in software </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#license">Previous =

</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#testing-is-necessa=
ry">Next=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>Probably over a billion (thousand million) hardware implementations =
of IEEE=20
754 arithmetic now exist in desktop and larger computers, cell phones, =
laser=20
printers, and other embedded devices. However, for some purposes, such =
as=20
simulating new processors, providing IEEE 754 access on older systems, =
and=20
allowing bit-for-bit identical results across different systems, it is =
necessary=20
to have a software implementation. </P>
<P>Because a software arithmetic system is a vital layer underneath =
other=20
packages, it <EM>must</EM> be highly portable; otherwise, it would =
compromise=20
the portability of those packages, and often, simply could not be used =
if it did=20
pose a porting barrier. </P>
<P>Here is a list of the software arithmetic packages that I know of. =
Some are=20
historical, some are commercial, and others are provided under generous=20
free-software or open-source licenses. </P>
<UL>
  <LI>
  <P>SANE (Standard Apple Numerics Environment) was used to provide=20
  floating-point arithmetic on old Apple Macintosh systems using the =
Motorola=20
  68K processor. </P>
  <P>SANE is no longer available, and was likely specific to the 68K, =
perhaps=20
  even having been written in assembly language, as other key Macintosh =
O/S=20
  components were to maximize performance on systems that were 200 to =
500 times=20
  slower than current top-end desktops. </P>
  <P>As far as I can tell, SANE was never released as a separate =
product, or in=20
  source form, and mention of it has pretty much disappeared from the =
Apple Web=20
  site. The acronym got reused at Apple to mean Scanner Access Now Easy. =
</P>
  <LI>
  <P>Donald Knuth's <TT>mmix-arith</TT> C-Web program, is available as =
part of=20
  the <A=20
  =
href=3D"http://www-cs-faculty.stanford.edu/~knuth/programs/mmix-20050331.=
tar.gz">MMIXware=20
  release </A>in the <TT>mmix-20050331.tar.gz</TT> archive. </P>
  <P>MMIX 2009 is a virtual machine whose native assembly code is MMIX, =
and its=20
  (still virtual) operating system is called NNIX. MMIX and its ancestor =
MIX has=20
  been used since 1968 in the famous <EM>Art of Computer =
Programming</EM> books=20
  to allow detailed machine-level analysis of algorithms. A modified gcc =

  supports compilation of C and possibly C++ into MMIX. </P>
  <P>More information on MMIX can be found at these Web sites: </P>
  <UL>
    <LI><A=20
    =
href=3D"http://www-cs-faculty.stanford.edu/~knuth/mmix.html">http://www-c=
s-faculty.stanford.edu/~knuth/mmix.html</A>
    <LI><A=20
    =
href=3D"http://mmixmasters.sourceforge.net/">http://mmixmasters.sourcefor=
ge.net/</A>
    <LI><A=20
    =
href=3D"http://www.gnu.org/software/mdk/mdk.html">http://www.gnu.org/soft=
ware/mdk/mdk.html</A></LI></UL>
  <P><TT>mmix-arith</TT> provides only the IEEE 754 32-bit and 64-bit =
formats.=20
  Neither the 80-bit nor the 128-bit extended formats are supported. It =
would=20
  take a fair amount of work to support them in <TT>mmix-arith</TT>, =
because the=20
  low-level primitives for bit shifting and the basic <TT>+</TT>, =
<TT>-</TT>,=20
  <TT>/</TT>, <TT>*</TT>, and <TT>%</TT> operators are specialized for =
the=20
  32-bit and 64-bit cases. </P>
  <P><TT>mmix-arith</TT> implicitly assumes 32 bit integers, and that=20
  <TT>sizeof(int)</TT> is 4 bytes. Curiously, it introduces types =
<TT>octa</TT>=20
  (byte) and <TT>tetra</TT> (byte) to hide implementation-dependent =
types when=20
  it needs 4-byte and 8-byte values, but it didn't do so for =
<TT>int</TT>, even=20
  though it won't work correctly if <TT>int</TT> is 16-bit or 36-bit. =
While=20
  32-bit integers are widely available today on common computers, the =
limitation=20
  is significant if someone comtemplates making this code work on =
historical=20
  pre-IEEE-754 computer systems, as I do. </P>
  <P><TT>mmix-arith</TT> requires 32-bit signed and unsigned integer =
types, but=20
  does not require 64-bit integer types. </P>
  <P>There is no public test suite for <TT>mmix-arith</TT>, but its =
author is=20
  famous for the care he takes to ensure correct software. Perhaps =
someone else=20
  will contribute a driver program and test suite. </P>
  <P><TT>mmix-arith.w</TT> is a literate-program file consisting of 1843 =
lines=20
  of intermixed prose and code. Processing with <TT>cweave</TT> produces =
a=20
  2606-line TeX file that when typeset is a 48-page =
comprehensively-indexed=20
  document describing the code. Processing with <TT>cweb</TT> produces a =

  1670-line C program that compiles cleanly into an object file with 34 =
external=20
  symbols. The machine-generated C code is run together and not very =
readable,=20
  but application of GNU <TT>indent</TT> with my favorite options =
produces a=20
  2336-line file with 1963 nonblank lines of clean C code. </P>
  <P>I give these measurements here to document the size of one =
programming=20
  project to implement IEEE 754 arithmetic in software. It is clearly =
modest=20
  enough that advanced programming classes could tackle this job with =
small=20
  student-programmer teams, and a single expert programmer might =
independently=20
  implement it in a week or two. Knuth is among the world's top =
programmers, and=20
  his algorithms are often clever, nonobvious, and fast. Module 28 on p. =
10 of=20
  the typeset document poses a challenge to readers: are there faster =
ways to=20
  implement a certain three of the key low-level primitives? </P>
  <P>The <TT>mmix-arith</TT> code is old-style (K&amp;R) C, and I have=20
  successfully compiled it with <TT>c89</TT>, <TT>cc</TT>, and =
<TT>c99</TT>=20
  compilers on several different Unix architectures. </P>
  <P>I expect that if a Web change file were provided to produce 1989 =
Standard C=20
  function declarations, the <TT>mmix-arith</TT> code should then also =
compile=20
  with C++ compilers. </P>
  <P>As a quick experiment to confirm that conjecture, I ran GNU=20
  <TT>protoize</TT> on the C file. It successfully converted most of the =
code,=20
  but not all of it. In a 10-minute editing job, I added the remaining=20
  prototypes, renamed one variable that is a reserved word in C++, added =

  <TT>#define</TT> for <TT>true</TT>, <TT>false</TT>, and <TT>bool</TT> =
to avoid=20
  confusion with native C++ names, and rewrote a single Boolean =
assignment to=20
  make it legal C++ (and also C). The code has now successfully compiled =
with=20
  several C++ compilers on at least five CPU architectures. All of my =
changes=20
  could be done via a Web change file as well, allowing automated =
production of=20
  C++ code from the C-Web source. </P>
  <LI>
  <P>John R. Hauser has written the <A=20
  href=3D"http://www.jhauser.us/arithmetic/SoftFloat.html">SoftFloat =
</A>package=20
  and a companion <A=20
  href=3D"http://www.jhauser.us/arithmetic/TestFloat.html">TestFloat =
</A>package.=20
  His Web site reports: </P>
  <BLOCKQUOTE><EM>SoftFloat fully implements the four most common=20
    floating-point formats: single precision (32 bits), double precision =
(64=20
    bits), extended double precision (80 bits), and quadruple precision =
(128=20
    bits). All required rounding modes, exception flags, and special =
values are=20
    supported. <TT>...</TT> SoftFloat's code for the extended =
double-precision=20
    and quadruple-precision formats depends on the existence of a 64-bit =
integer=20
    type in C. If the C compiler used to compile SoftFloat does not =
support=20
    64-bit integers, SoftFloat will be limited to single and double =
precisions=20
    only. </EM></BLOCKQUOTE>
  <P>SoftFloat consists of 2807 lines of code in the <TT>bits32</TT> =
tree, and=20
  6100 lines of code in the <TT>bits64</TT> tree, exclusive of the =
timing test=20
  code. This is almost four times the size of <TT>mmix-arith.c</TT>, but =
this=20
  package also provides twice as many formats. </P>
  <P>The detailed distribution notes suggest that porting to new =
platforms might=20
  be difficult. At least for most current systems, this is not the case. =
The=20
  <TT>Makefile</TT>s hardcode the compiler to be GNU <TT>gcc</TT>, but a =

  two-line edit allows selection of a different compiler. The entire =
package=20
  contains only two source files, one for SoftFloat itself, and one for =
timing=20
  tests. I have successfully built it and run the timing tests on these =
current=20
  and recent major platforms, covering all of the important desktop CPU=20
  architectures: </P>
  <UL>
    <LI>Apple GNU/Linux 2.3 PowerPC (gcc)=20
    <LI>Apple Mac OS 10.3.2 PowerPC (gcc)=20
    <LI>Compaq OSF/1 5.1 Alpha (gcc and cc)=20
    <LI>DEC Alpha OSF/1 4.0 (gcc)=20
    <LI>FreeBSD 5.0 Pentium III (gcc)=20
    <LI>GNU/Linux Fedora Core 3 AMD64 (gcc)=20
    <LI>GNU/Linux Red Hat Advanced Server 3 IA-64 (gcc icc)=20
    <LI>Hewlett-Packard HP-UX 11.11 PA-RISC (gcc)=20
    <LI>NeXT Dimension Mach 3.3 Motorola 68040 (gcc)=20
    <LI>OpenBSD 3.2 Pentium III (gcc)=20
    <LI>SGI Origin/200-4 IRIX 6.5 MIPS R10000 (gcc)=20
    <LI>Sun Solaris 10 IA-32 (gcc and c99)=20
    <LI>Sun Solaris 8 and 9 SPARC (gcc and cc) </LI></UL>
  <P>With some native C compilers, I had to change source file line =
terminators=20
  from CR LF to LF, a trivial job with my <A=20
  href=3D"http://www.math.utah.edu/pub/dosmacux/">dos2ux </A>tool. On =
the two=20
  Alpha systems, for the native compilers, I had to add two preprocessor =

  statements to undefine <TT>TRUE</TT> and <TT>FALSE</TT> before their =
use in an=20
  <TT>enum</TT>. No other source code tweaks were necessary anywhere. =
</P>
  <P>I conclude that SoftFloat is highly portable to common current =
systems, and=20
  with a bit more packaging work, could be made easily installable on =
millions=20
  of systems. </P>
  <LI>
  <P>Mike Cowlishaw and his group at IBM Hursley Laboratory in the UK =
have=20
  developed an implementation of IEEE 754/854 <A=20
  href=3D"http://www2.hursley.ibm.com/decimal/">decimal arithmetic =
</A>that is=20
  being used as a testbed for both the revision of the IEEE 754 =
standard, as=20
  well as for possible future decimal floating-point arithmetic =
hardware. The=20
  <EM>Implementations</EM> section of their Web site contains pointers =
to=20
  several other packages designed to support decimal floating-point =
arithmetic=20
  in software. </P>
  <LI>
  <P>Analog Device's <A=20
  =
href=3D"http://www.analog.com/UploadedFiles/Application_Notes/47485184002=
118EE185.pdf">IEEE=20
  754 software library </A>provides 32-bit and 64-bit arithmetic for the =

  Blackfin fixed-point embedded processor. </P>
  <LI>
  <P>The <A href=3D"ftp://ftp.gnu.org/gnu/gcc">GNU compiler collection=20
  </A>(<TT>gcc</TT>) distributions contain the 4011-line file=20
  <TT>gcc/real.c</TT> that implements a software floating-point =
emulation for=20
  processors that lack floating-point hardware. According to the =
preamble=20
  commments, it is not exactly IEEE 754 compliant. It has a 160-bit =
significand=20
  in [0.5,1), and a 27-bit exponent. The wider format is used to emulate =
the=20
  32-bit, 64-bit, 80-bit, and 128-bit IEEE 754 formats. It can be =
selected at=20
  compile time on some of the platforms that <TT>gcc</TT> runs on by =
using the=20
  <TT>-msoft-float</TT> compiler option. Unfortunately, on several =
systems, I=20
  found that linking fails because the needed run-time library support =
is=20
  missing, and on others, nonsensical results are produced, possibly =
because the=20
  I/O library is being passed bit patterns that do not correspond to the =

  expected IEEE 754 encodings. </P>
  <LI>
  <P>Others?? </P>
  <LI>
  <P>Others?? </P>
  <LI>
  <P>Others?? =
</P></LI></UL><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dtesting-is-necessary>Why testing is necessary =
</A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#ieee-754-soft">Pre=
vious=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#c-with-fortran">Ne=
xt=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>Computer systems are now so ubiquitous that most users assume that =
computers=20
are reliable (at least, once their desktop system has been rebooted for =
the=20
seventh time today). After all, billions of dollars were spent in their=20
development, and hundreds of millions of people use them, so computers =
must be=20
trustworthy. Right? Wrong! </P>
<P>Schryer's report cited in the <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#schryer-report">bi=
bliography=20
</A>below documents case after case of egregious failures of =
floating-point=20
arithmetic in computer systems. Similar models of the same architecture =
were=20
found to behave differently, and sometimes, a program run on the same =
system=20
behaved differently on successive runs. In several cases, the faults =
were traced=20
to loose boards or wiring connections, and in others, to errors (`bugs') =
in=20
microcode or low-level arithmetic circuitry. </P>
<P>Modern systems built from microprocessors have radically reduced the =
number=20
of connections that are visible, and subject to looseness or dirt. =
Nevertheless,=20
there are still many sources of failure, and not only from the tens to =
hundreds=20
of millions of transistors in the microprocessor itself. </P>
<P>Perhaps the most spectacular, and expensive, was the 1995 Intel =
Pentium=20
floating-point divide flaw. After initial corporate denials, and =
denigrations of=20
the problem and its human reporters, Intel was ultimately forced to =
admit its=20
error, and make a massive recall of the flawed chips. The total cost to =
the=20
corporation was about $480M! </P>
<P>Modern computer arithmetic is based largely on the <EM>IEEE 754 =
Standard for=20
Binary Floating-Point Arithmetic</EM>. This Standard defines required =
and=20
implementation-dependent behavior, but does not specify how the Standard =
is to=20
be implemented. A computer vendor is free to implement the Standard =
entirely in=20
hardware, entirely in software, or in a combination of the two. </P>
<P>The AMD AMD-64 (Opteron), Intel IA-32 (formerly, x86), =
Hewlett-Packard/Intel=20
IA-64, Motorola 68K, and IBM Power and PowerPC systems are examples of=20
hardware-only implementations. </P>
<P>Apple's SANE (Standard Apple Numeric Environment) is an example of a=20
software-only implementation. </P>
<P>Most other vendors of RISC systems, including HP/Compaq/DEC Alpha,=20
Hewlett-Packard PA-RISC, SGI MIPS, and Sun SPARC use a combination of =
hardware=20
and software. The `easy', and most common, cases are handled in =
hardware, but=20
traps must be made to software to handle remaining cases. Typically,=20
floating-point exception handling, and generation of special values =
(subnormal=20
numbers, NaN, and Infinity) are done in software. </P>
<P>There have also been cases where lower-cost entry-level computer =
systems used=20
more software components in the arithmetic implementation than in =
higher-cost=20
advanced systems, so even within an architecture family, there can be=20
differences in behavior of the same program from the same executable =
file. </P>
<P>Computer users everywhere are all-too-familiar with software bugs. =
Current=20
operating system architectures increase the number of places where such =
errors=20
can occur. In the early days of computing, and of microprocessors, =
programs ran=20
almost on bare hardware. Today, a typical program uses several different =

run-time libraries that are not part of its executable image in the file =
system.=20
Bugs can arise from code-generation errors in the compiler which =
compiled the=20
program, or from logic errors in the user program itself, or from the =
run-time=20
libraries, or from interrupt handlers in the operating system. Either =
the=20
libraries or the operating system might have changed since the last time =
you ran=20
your program. In the case of network-aware languages like Java, Limbo, =
and C#,=20
failures can arise from the network, or on remote systems over which you =
have no=20
control. Errors can even be circular: an otherwise correctly-working =
compiler=20
might fail because of an O/S change, producing user code that fails. =
</P>
<P>The growing recognition of the importance of continual testing has =
led the=20
Free Software Foundation to encourage the inclusion of extensive =
validation=20
suites in their software distributions, so that the remote installer can =
verify=20
during installation that the software is performing as intended. In =
principle,=20
there is no reason why this testing could not continue after =
installation as=20
well. <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#schryer-report">Sc=
hryer=20
</A>documents several cases where off-peak hours in commercial systems =
were=20
devoted to rerunning software test suites. </P>
<P>You might ask: why can one not simply do exhaustive testing of the =
arithmetic=20
system? The answer is: it is generally impossible to do so. In 32-bit =
precision,=20
there are about four billion different numbers (because 2<SUP>32</SUP> =
=3D=20
4,294,967,296). At a computation speed of one result per nanosecond =
(achievable=20
on advanced single processors in 2001), exhaustive testing of the =
<EM>unary</EM>=20
square root function would take only four seconds, and many vendors have =
done=20
such testing. However, testing of a single <EM>binary</EM> operation, =
like add,=20
subtract, multiply, or divide, would take four billion times longer, or =
more=20
than 136 years. In 64-bit precision, the unary operation test would take =
136=20
years, and the binary operation test, 584 billion years, which is many =
times the=20
age of the universe. In 128-bit precision, testing would take...well, =
you get=20
the idea! </P>
<P>In the case of IEEE 754 floating-point arithmetic, vendor =
implementations may=20
be <EM>imperfect</EM>, or <EM>inexplicable</EM>, or <EM>incomplete</EM>, =
or=20
<EM>inefficient</EM>, and programming languages support may be=20
<EM>deficient</EM>: </P>
<UL>
  <LI>Intel IA-32 processors, and possibly also MIPS processors earlier =
than the=20
  R4000, implement only one kind of NaN, without a distinction between =
quiet and=20
  signaling NaNs.=20
  <LI>HP/Compaq/DEC Alpha, Intel IA-32, and HP/Intel IA-64 processors =
generate=20
  negative NaNs, independent of the sign of the operands. However, it is =

  possible to negate a negative NaN to get a positive NaN.=20
  <LI>The default on HP/Compaq/DEC Alpha systems, and Sun's Fortran 90 =
and 95=20
  compilers, is to terminate processing at a floating-point exception; =
special=20
  compiler options are needed to get the intended nonstop behavior of =
IEEE 754.=20
  Alpha systems in particular suffer a very serious performance hit when =
this is=20
  done.=20
  <LI>Some systems do not implement gradual underflow to subnormal =
numbers,=20
  underflowing abruptly to zero instead.=20
  <LI>Even though IBM introduced quadruple precision hardware in 1967 on =
some=20
  System/360 models, and has continued to do so, right up to 1999, when =
they=20
  introduced the <A=20
  =
href=3D"http://www.research.ibm.com/journal/rd/435/schwarz.html">System/3=
90 G5=20
  processors </A>with both IBM and IEEE 754 floating-point arithmetic. =
In=20
  high-level languages (C, C++, Fortran, ...), the S/390 GNU/Linux=20
  implementation provides access only to IEEE 754 arithmetic, and the =
128-bit=20
  format may not be accessible at all (reader confirmation is welcome!); =
I no=20
  longer have access to such a system to check.=20
  <LI>As far as I can determine, apart from IBM, no other vendor has =
ever=20
  shipped quadruple-precision hardware for IEEE 754 arithmetic. Larger =
models of=20
  the now-defunct DEC VAX product line <A=20
  href=3D"http://www.vajhoej.dk/anonymous/INST/SUMMARY.TXT">are reported =
</A>to=20
  have had the VAX 128-bit H-floating type implemented in hardware.=20
  <LI>Software implementations of quadruple precision have been found to =
be=20
  seriously flawed on some systems, IBM RS/6000 AIX and SGI IRIX in =
particular;=20
  that story is expected to appear in a paper co-authored by NHFB in =
<EM>ACM=20
  Transactions on Mathematical Software</EM>.=20
  <LI>Only some Fortran compilers, and very few C/C++ compilers, support =

  quadruple precision, and Java does not do so at all.=20
  <LI>Signed zero is handled poorly on most systems, and sometimes, is=20
  apparently absent. Even when the underlying architecture supports it,=20
  compilers and run-time libraries often botch it.=20
  <LI>While NaN and Infinity can generally be output to text files, =
their exact=20
  appearance can be eclectic, and almost no systems can then read them =
back in=20
  correctly.=20
  <LI>Processing of NaN and Infinity values can take orders of magnitude =
longer=20
  on systems that require software support for them, and even on systems =
with=20
  hardware-only implementations, there can be significant slowdowns for =
such=20
  operands.=20
  <LI>The architectural specification of Java requires IEEE 754 =
arithmetic, but=20
  only a subset of it, and overspecifies its behavior, with severe =
performance=20
  loss on systems with multiply-add instructions (most RISC processors), =
or=20
  extended-length registers (Intel IA-32 and HP/Intel IA-64). See Kahan =
and=20
  Darcy's biting paper, <EM>How Java's Floating-Point Hurts Everyone=20
  Everywhere</EM>, in the <A=20
  =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#kahan-java-hurt">b=
ibliography.=20
  </A>
  <LI>There is absolutely <EM>no standardization whatever</EM> for =
software=20
  access to IEEE 754 floating-point rounding mode control, exception =
masking,=20
  and interrupt handling in <EM>any</EM> programming language. Too many=20
  compilers and associated run-time libraries completely lack such =
support,=20
  sometimes leaving the programmer no recourse but low-level nonportable =

  machine-dependent assembly language programming. <STRONG>It is simply =
an=20
  outrage that this situation still exists more than twenty years after =
the=20
  first hardware implementation of IEEE 754, the Intel 8087, was shipped =
to=20
  customers, with hundreds of millions of processors today supporting =
IEEE=20
  754.</STRONG>=20
  <LI>Internationalization of software, especially through the Unicode =
and ISO=20
  10646 character-set developments since the early 1990s, has become a =
hot=20
  topic. Although programming languages have almost universally =
supported the=20
  English number representation of 3.141592653589793 and 6.022E+23, =
users now=20
  demand national formats, with commas or spaces instead of periods=20
  (3,141.592.653.589.793, or 3,141&nbsp;592&nbsp;653&nbsp;589&nbsp;793, =
or ...),=20
  digit clustering (one million in India is written 10,00,000, and =
pronounced=20
  `ten lakhs'), and currency symbols. IEEE 754 NaN and Infinity are =
based on=20
  English words: should French users see PUN (<EM>pas un nombre</EM>), =
and=20
  Danish users IEN and UEN (<EM>ikke-et-nummer</EM> and =
<EM>uendelig</EM>)?=20
  English-speaking people in India may be quite happy, and amused, with =
NaN,=20
  because it is a delicious North Indian bread! It seems to me that =
these issues=20
  are going to pose enormous challenges to software design, and also =
significant=20
  barriers to data portability. =
</LI></UL><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dc-with-fortran>Using C/C++ and Fortran together =
</A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#testing-is-necessa=
ry">Previous=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#fortran-notes">Nex=
t=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>The mixed-language programming issue is relevant to some of the =
software in=20
this collection, and also to many programmers of engineering and =
scientific=20
software. A separate lengthy document on the subject, entitled <A=20
href=3D"http://www.math.utah.edu/software/c-with-fortran.html"><EM>Using =
C and C++=20
with Fortran,</EM> </A>provides much useful information. =
</P><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dfortran-notes>Notes on Fortran programs </A></H1><SMALL><A =

href=3D"http://www.math.utah.edu/~beebe/software/ieee/#c-with-fortran">Pr=
evious=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#c-notes">Next=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>Unless otherwise noted below, all of the Fortran programs adhere to a =

superset of the ANSI Fortran Standard, formally known as <EM>American =
National=20
Standard Programming Language FORTRAN, ANSI X3.9-1978</EM>, <EM>CSA =
Standard=20
Z243.18-1980 January, 1980</EM>, and <EM>ISO/IEC 1539-1980</EM>. =
Although the=20
ANSI Fortran Standard, published on 3-Apr-1978, was late, the language =
is=20
generally called Fortran 77, and most vendors name their compilers =
<TT>f77</TT>.=20
</P>
<P>There are four widely-supported language extensions that are used in =
some or=20
all of the test programs: (a) lowercase letters in keywords and =
variables, (b)=20
quadruple precision (<TT>REAL*16</TT>), (c) <TT>Zw.d</TT> hexadecimal=20
<TT>FORMAT</TT> items, and (d) <TT>Z'hhhhhhhh'</TT> hexadecimal =
constants in=20
<TT>DATA</TT> statement initializer lists. In practice, none of these =
extensions=20
proves a barrier to portability, and all compile without problems on all =
major=20
UNIX platforms. </P>
<P>All of the Fortran programs should be compilable with compilers for =
Fortran=20
77, Fortran 90, Fortran 95, and High-Performance Fortran, subject to =
these=20
special considerations: </P>
<UL>
  <LI><A name=3Dfortran-nonstop>With </A>IBM's Fortran 90 and 95 =
compilers on AIX,=20
  <TT>xlf90</TT> and <TT>xlf95</TT>, it is necessary to use the=20
  <B><TT>-qfixed</TT></B> option to inform the compilers that the code =
is=20
  written in Fortran 77 fixed format, rather than Fortran 90/95 free =
format.=20
  <LI>Similarly, with the NAG Fortran compilers, <TT>nagf90</TT> and=20
  <TT>nagf95</TT>, use the <B><TT>-fixed</TT></B> option (in practice, =
the NAG=20
  compilers figure out the source format, and always issue a warning for =
fixed=20
  source programs).=20
  <LI>Fortran compilers for the HP/Compaq/DEC Alpha processors on both =
OSF/1 and=20
  GNU/Linux regrettably do not default to generating code for IEEE 754 =
nonstop=20
  behavior: execution is abruptly terminated in the event of =
floating-point=20
  exceptions. Most of the programs here intentionally generate such =
exceptions.=20
  For the HP/Compaq/DEC <TT>f77</TT>, <TT>f90</TT>, and <TT>f95</TT> =
compilers=20
  on OSF/1, and their <TT>fort</TT> compiler on GNU/Linux, the=20
  <B><TT>-fpe3</TT></B> option is required to get proper nonstop =
behavior. For=20
  the GNU <TT>g77</TT> compiler on both operating systems, the=20
  <B><TT>-mieee</TT></B> option is required.=20
  <LI>For the NAG <TT>nagf90</TT> and <TT>nagf95</TT> compilers, the=20
  <B><TT>-ieee=3Dfull</TT></B> option is needed to get nonstop behavior. =
</LI></UL>
<P>The NAG compilers are unusual, in that they translate Fortran to C, =
and then=20
invoke the native C compiler to compile to machine code. This means that =
NAG=20
could potentially offer them on every platform for which a C compiler is =

available. The NAG Fortran 90 compiler was the first compiler available =
for that=20
language, as far as I know. </P>
<P>The AT&amp;T (now Lucent) Bell Laboratories Fortran-to-C translator,=20
<TT>f2c</TT>, with its Fortran compiler wrapper, <TT>fc</TT>, also =
potentially=20
provides Fortran support for any platform that has a working C compiler. =

Unfortunately, support for quadruple precision is not widely available =
in C=20
compilers, and <TT>f2c</TT> at present rejects Fortran programs using =
that=20
extended data type. I have recommended to its developers that this =
serious=20
limitation be lifted. </P>
<P>On GNU/Linux on Intel IA-32, the only Fortran compilers available =
that=20
provide support for 128-bit IEEE quadruple precision are Lahey/Fujitsu=20
<TT>lf95</TT> and Intel <TT>ifort</TT> (from version 8 released in late =
2003).=20
</P>
<P>Unfortunately, in Lahey/Fujistu Release L5.50a (1999), floating-point =

exceptions abruptly terminate execution with no possibility of nonstop =
behavior,=20
making this otherwise excellent Fortran compiler of doubtful utility for =
serious=20
scientific work. I have reported this problem to the vendor. It appears =
to be=20
fixed in the L6.20a release (late 2003). The Intel compiler has no such =
problem.=20
</P><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dc-notes>Notes on C/C++ programs </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#fortran-notes">Pre=
vious=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#java-notes">Next=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>All programs written in C adhere to 1989 ANSI/ISO Standard C, =
formally known=20
as <EM>ISO/IEC 9899:1999(E) Programming languages -- C</EM>, or C89 for =
short.=20
They can also be compiled and run with any C++ compiler. Sadly, the =
dozens of=20
C++ implementations available to me are at varying stages of evolution =
toward=20
the 1998 ISO C++ Standard., and it is not yet practical to write C++ =
code that=20
works with all them, not even a simple <EM>Hello, world</EM> example. =
Thus, I=20
generally write in C, rather than C++, because portability is supremely=20
important to me. </P>
<P>To avoid catastrophic overwriting by Fortran-to-C translators, no C =
source=20
file has the same base name as a corresponding Fortran source file: a=20
disambiguating numeric suffix is added to the C file base name. </P>
<P>All C programs can also be compiled with old-style Kernighan and =
Ritchie C.=20
However, inasmuch as I now have access to only one such old compiler, =
with more=20
than 35 others supporting 1989 Standard C, I no longer attempt to retain =
K&amp;R=20
compatibility in new code. </P>
<P><A name=3Dc-nonstop>As </A>with Fortran compilers on some systems, C =
compilers=20
on those systems may also require special options to get nonstop =
behavior. On=20
HP/Compaq/DEC Alpha, both OSF/1 and GNU/Linux, GNU <TT>gcc</TT> and =
<TT>g++</TT>=20
need the <B><TT>-mieee</TT></B> option. On OSF/1, HP/Compaq/DEC =
<TT>cc</TT>,=20
<TT>c89</TT>, and <TT>cxx</TT> need the <B><TT>-ieee</TT></B> option. =
</P>
<P>Since not all C and C++ compilers recognize the <B><TT>long =
double</TT></B>=20
data type, most programs that use it bracket the code with a =
preprocessor=20
conditional that tests whether the symbol =
<B><TT>HAVE_LONG_DOUBLE</TT></B> has=20
been defined. Thus, the C programs here should be compiled with an =
option to=20
define that symbol if <B><TT>long double</TT></B> is supported.=20
Sensibly-designed C compilers that still lack full support for that data =
type=20
accept it, but map it to type <B><TT>double</TT></B> with a warning, =
rather than=20
rejecting the program as erroneous. </P>
<P>Similarly, code that uses the <B><TT>long long</TT></B> data type is=20
bracketed by a conditional that tests whether =
<B><TT>HAVE_LONG_LONG</TT></B> has=20
been defined. =
</P><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Djava-notes>Notes on Java programs </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#c-notes">Previous =

</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#maple-notes">Next =

</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>Compilation of a <TT>.java</TT> source code file produces a binary=20
<TT>.class</TT> file, the analog of a <TT>.o</TT> file from most other=20
UNIX/POSIX/GNU compilers. Unfortunately, some Java implementations lack =
a=20
program to do the next step: link the <TT>.class</TT> file into an =
executable=20
program that can be invoked by name, just like programs written in any =
other=20
programming language. When such a program is available, it is usually =
called=20
<TT>javald</TT>, and the <TT>.class</TT> file <EM>must</EM> be =
preserved.=20
Otherwise, Java programs must be run like this: <TT>java foo</TT>, where =

<TT>foo.class</TT> must already exist. </P>
<P>Java programs have a peculiarity that may be unique among programming =

languages: the class name in a Java source file must also be used for =
the file=20
name, with extension <TT>.java</TT>. =
</P><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dmaple-notes>Notes on Maple programs </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#java-notes">Previo=
us=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#caveats">Next=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>A few programs here are written in the <A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/index-table-m.html#maple-ext=
ract">Maple=20
programming language, </A>a proprietary, but widely used, symbolic =
algebra=20
system developed starting in the early 1980s at the University of =
Waterloo,=20
Waterloo, Ontario, Canada, and later spun off into a company, <A=20
href=3D"http://www.maplesoft.com/">Waterloo Maple Software, </A>which =
continues=20
active development, marketing, and support of Maple. </P>
<P>Translations to other symbolic algebra languages, and to open source =
code in=20
C or C++ using, for example, the GNU Multiple Precision Arithmetic =
Library,=20
<TT>gmp</TT>, will be most welcome. =
</P><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dcaveats>Caveats </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#maple-notes">Previ=
ous=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#catalog">Next=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<BLOCKQUOTE>
  <TABLE border=3D10>
    <TBODY>
    <TR>
      <TD><FONT color=3D#ff0000>WARNING: Programs that rely on =
vendor-provided=20
        run-time libraries for decimal&lt;--&gt;binary conversion are=20
        <STRONG>always suspect</STRONG>: those conversions may be =
inaccurate.=20
        </FONT></TD></TR></TBODY></TABLE></BLOCKQUOTE>
<P>Fortran programs assume that unit 5 is open and connected to standard =
input,=20
and unit 6 is open and connected to standard output. This practice is =
universal=20
on UNIX systems, and follows a tradition established by IBM in the =
1960s, and=20
adopted by all sensible Fortran compiler vendors. </P>
<P>Some compilers need special compilation options to get IEEE 754 =
nonstop=20
behavior, and most of the test programs here require that behavior. See =
the=20
notes above for <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#c-nonstop">C/C++ =
</A>and <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#fortran-nonstop">F=
ortran.=20
</A></P>
<P>Some architectures have registers that are larger than memory words. =
These=20
include the now-defunct <EM>Honeywell Series 6000</EM>, the =
almost-disappeared=20
<EM>Motorola 68K</EM>, the widely-used <EM>Intel IA-32</EM>, and its =
planned=20
replacement, the <EM>Hewlett-Packard/Intel IA-64</EM>. In most =
applications, the=20
extra range and precision of intermediate computations in such registers =
is=20
beneficial. However, in floating-point test programs, it can be harmful. =
</P>
<P>For example, a program that determines the machine epsilon by the =
simple=20
pseudocode </P>
<BLOCKQUOTE><TT>x =3D 1.0<BR>while ((1.0 + (x / 2.0)) &gt;=20
  1.0)<BR>&nbsp;&nbsp;&nbsp;&nbsp;x =3D x / 2.0<BR>print x; =
</TT></BLOCKQUOTE>
<P>will produce a smaller value than expected, because of the extra =
precision of=20
register computations. </P>
<P>For that reason, the test programs here sometimes have to resort to=20
subterfuges to force intermediate data out of long registers into =
memory. They=20
do this by calling short functions that simply return their arguments. =
This=20
achieves their intent with most compilers, but optimizing compilers that =

silently inline functions may defeat them. </P>
<P>In principle, the C89/C++98/Java type qualifier <TT>volatile</TT> =
could be=20
used to avoid the function-call subterfuge, but that keyword isn't =
recognized by=20
older compilers, so none of the C/C++/Java test programs use it. Fortran =
offers=20
no analogue of <TT>volatile</TT> at all. </P>
<P>In large packages, such functions need to be moved to separate files =
to=20
prevent inlining, but I have not done so for these simple test programs. =
[In=20
principle, an extremely clever executable image loader could still =
inline such=20
separately-compiled functions, but I am unaware in 2004 of any system =
that does=20
so.] </P>
<P>I know of no C, C++, or Fortran compiler on these platforms that does =
this=20
inlining when compiling at the lowest (usually, debug) optimization =
level. Thus,=20
for UNIX compilers, use the <B><TT>-g</TT></B> debug option, and avoid=20
<B><TT>-O<I>n</I></TT></B> options. Few of these programs take more than =
a few=20
seconds to run, and most take much less, so code optimization is =
definitely not=20
of concern. =
</P><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dcatalog>Catalog of programs </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#caveats">Previous =

</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#futures">Next=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>If more than a few of these programs are of interest to you, you can =
fetch=20
the entire contents of this directory tree in any of these <A=20
name=3Darchive-formats>archive formats:<BR></A></P>
<UL>
  <LI><A=20
  =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/ieee.jar"><TT>ieee.=
jar</TT>,<BR></A>
  <LI><A=20
  =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/ieee.tar.gz"><TT>ie=
ee.tar.gz</TT>,<BR></A>
  <LI><A=20
  =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/ieee.zip"><TT>ieee.=
zip</TT>,<BR></A>
  <LI><A=20
  =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/ieee.zoo"><TT>ieee.=
zoo</TT>.=20
  </A></LI></UL>
<TABLE>
  <TBODY>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/COPYING"><TT>COPYIN=
G</TT>=20
      </A></TD>
    <TD>GNU GENERAL PUBLIC LICENSE, Version 2, June 1991. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/adx2.c"><TT>adx2.c<=
/TT>=20
      </A></TD>
    <TD>Implementation of Fortran <TT>REAL</TT> function =
<TT>adx(x,n)</TT> in=20
      C, to return <TT>x * base**n</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/adx.f"><TT>adx.f</T=
T>=20
      </A></TD>
    <TD>Fortran <TT>REAL</TT> function <TT>adx(x,n)</TT>, to return =
<TT>x *=20
      base**n</TT>; </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/args.h"><TT>args.h<=
/TT>=20
      </A></TD>
    <TD>C header file to support K&amp;R, Standard C, and Standard C++ =
coding.=20
    </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/chkinexact.c"><TT>c=
hkinexact.c</TT>=20
      </A></TD>
    <TD>C program to test the setting of floating-point exception flags =
on Sun=20
      Solaris. Although all IEEE 754 implementations have these flags, =
the=20
      interface to them is unique to each vendor. Eventually, a common =
interface=20
      needs to be written to allow exception-flag access everywhere. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/configure"><TT>conf=
igure</TT>=20
      </A></TD>
    <TD>Dummy UNIX/POSIX/GNU shell script to allow a building, testing, =
and=20
      installing with the GNU standard procedure: <TT>./configure =
&amp;&amp;=20
      make all check install</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/copysign.c"><TT>cop=
ysign.c</TT>=20
      </A></TD>
    <TD>C program to test the IEEE 754 <TT>copysign()</TT> function. =
That=20
      function is not part of 1989 Standard C, so this program will not =
work on=20
      some systems. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/dadx2.c"><TT>dadx2.=
c</TT>=20
      </A></TD>
    <TD>Implementation of Fortran <TT>DOUBLE PRECISION</TT> function=20
      <TT>dadx(x,n)</TT> in C, to return <TT>x * base**n</TT>. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/dadx.f"><TT>dadx.f<=
/TT>=20
      </A></TD>
    <TD>Fortran <TT>DOUBLE PRECISION</TT> function <TT>dadx(x,n)</TT>, =
to=20
      return <TT>x * base**n</TT>; </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/datasize.c"><TT>dat=
asize.c</TT>=20
      </A></TD>
    <TD>C program to report the implementation sizes of all C primitive =
data=20
      types. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/datasize.sh"><TT>da=
tasize.sh</TT>=20
      </A></TD>
    <TD>UNIX/POSIX/GNU shell script to compile and run =
<TT>datasize.c</TT>=20
      with a C compiler defined by the <TT>CC</TT> environment variable. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/datasize-all.sh"><T=
T>datasize-all.sh</TT>=20
      </A></TD>
    <TD>UNIX/POSIX/GNU shell script to compile and run =
<TT>datasize.c</TT>=20
      with all known C compilers. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/datasize-all.txt"><=
TT>datasize-all.txt</TT>=20
      </A></TD>
    <TD>Test results from <TT>datasize-all.sh</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/deps2.c"><TT>deps2.=
c</TT>=20
      </A></TD>
    <TD>Fortran <TT>DOUBLE PRECISION</TT> function implemented in C to =
compute=20
      the generalized machine epsilon. This implementation works by fast =

      low-level bit manipulation. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/deps.f"><TT>deps.f<=
/TT>=20
      </A></TD>
    <TD>Fortran <TT>DOUBLE PRECISION</TT> function <TT>deps(x)</TT> to =
compute=20
      the generalized machine epsilon. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/depsiter.c"><TT>dep=
siter.c</TT>=20
      </A></TD>
    <TD>Fortran <TT>DOUBLE PRECISION</TT> function implemented in C to =
compute=20
      the generalized machine epsilon. This implementation works by =
looping.=20
  </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/dintxp.c"><TT>dintx=
p.c</TT>=20
      </A></TD>
    <TD>Fortran <TT>INTEGER</TT> function <TT>dintxp(x)</TT> implemented =
in C=20
      to return the exponent of the base in the representation of =
<TT>DOUBLE=20
      PRECISION</TT> <TT>x</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/disden.c"><TT>disde=
n.c</TT>=20
      </A></TD>
    <TD>Fortran <TT>LOGICAL</TT> function <TT>disden(x)</TT> implemented =
in C=20
      to return <TT>.TRUE.</TT> if <TT>DOUBLE PRECISION</TT> <TT>x</TT> =
is=20
      subnormal (formerly, denormalized), and <TT>.FALSE.</TT> =
otherwise. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/disinf.c"><TT>disin=
f.c</TT>=20
      </A></TD>
    <TD>Fortran <TT>LOGICAL</TT> function <TT>disinf(x)</TT> implemented =
in C=20
      to return <TT>.TRUE.</TT> if <TT>DOUBLE PRECISION</TT> <TT>x</TT> =
is=20
      infinite, and <TT>.FALSE.</TT> otherwise. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/disnan.c"><TT>disna=
n.c</TT>=20
      </A></TD>
    <TD>Fortran <TT>LOGICAL</TT> function <TT>disnan(x)</TT> implemented =
in C=20
      to return <TT>.TRUE.</TT> if <TT>DOUBLE PRECISION</TT> <TT>x</TT> =
is a=20
      NaN, and <TT>.FALSE.</TT> otherwise. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/dmachar.f"><TT>dmac=
har.f</TT>=20
      </A></TD>
    <TD>Fortran subroutine to determine the characteristics of the host=20
      <TT>DOUBLE PRECISION</TT> floating-point system. [This program was =
written=20
      by W. J. Cody, Jr., as part of the ELEFUNT test package.] =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/dnxtaft.f"><TT>dnxt=
aft.f</TT>=20
      </A></TD>
    <TD>Fortran <TT>DOUBLE PRECISION</TT> function <TT>dnxtaft(x,y)</TT> =
to=20
      return the next floating-point number after <TT>x</TT> in the =
direction of=20
      <TT>y</TT>. This version uses slow iteration instead of fast bit=20
      manipulation. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/dran.f"><TT>dran.f<=
/TT>=20
      </A></TD>
    <TD>Fortran <TT>DOUBLE PRECISION</TT> function to return a =
pseudo-random=20
      number uniformly distributed on (0,1). [This program was written =
by W. J.=20
      Cody, Jr., as part of the ELEFUNT test package.] </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/drandl.f"><TT>drand=
l.f</TT>=20
      </A></TD>
    <TD>Fortran <TT>DOUBLE PRECISION</TT> function to return a =
pseudo-random=20
      number logarithmically distributed on (1,<TT>dexp(x)</TT>). [This =
program=20
      was written by W. J. Cody, Jr., as part of the ELEFUNT test =
package.]=20
  </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/dsetxp.c"><TT>dsetx=
p.c</TT>=20
      </A></TD>
    <TD>Fortran <TT>DOUBLE PRECISION</TT> function <TT>dsetxp(x,n)</TT>=20
      implemented in C to return <TT>(fraction of x) * base**n</TT>, =
that is, to=20
      replace the exponent field of a copy of <TT>x</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/dsqrt.f"><TT>dsqrt.=
f</TT>=20
      </A></TD>
    <TD>Fortran <TT>DOUBLE PRECISION</TT> square root function. This was =

      written for an introductory class on scientific programming to =
show how=20
      one Fortran elementary function can be implemented; see below for=20
      documentation. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/dssqrt.f"><TT>dssqr=
t.f</TT>=20
      </A></TD>
    <TD>Fortran <TT>REAL</TT> square root function, with intermediate=20
      computation in <TT>DOUBLE PRECISION</TT>. This was written for an=20
      introductory class on scientific programming to show how one =
Fortran=20
      elementary function can be implemented; see below for =
documentation.=20
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/dtanh.f"><TT>dtanh.=
f</TT>=20
      </A></TD>
    <TD>Fortran <TT>DOUBLE PRECISION</TT> hyperbolic tangent function. =
This=20
      was written for an introductory class on scientific programming to =
show=20
      how one Fortran elementary function can be implemented; see below =
for=20
      documentation. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/elefunt.tar.gz"><TT=
>elefunt.tar.gz</TT>=20
      </A><IMG src=3D"http://www.math.utah.edu/images/new2.gif"> <IMG=20
      src=3D"http://www.math.utah.edu/images/new2.gif"> <IMG=20
      src=3D"http://www.math.utah.edu/images/new2.gif"> </TD>
    <TD>ELEFUNT elementary function test package. The Fortran code was =
written=20
      by W. J. Cody, Jr. and W. Waite, and described in their excellent =
book=20
      <EM>Software Manual for the Elementary Functions</EM>, =
Prentice-Hall=20
      (1980), ISBN 0-13-822064-6, LCCN QA331 .C635 1980. The C =
translation was=20
      done by hand by Kenneth Stoner, then a high-school student, with=20
      assistance from Nelson Beebe, before Fortran-to-C translators were =

      available. The updated release of this package (June 2002) =
includes new=20
      quadruple-precision ELEFUNT packages for Fortran and C/C++, and =
new=20
      single- and double-precision ELEFUNT packages for Java. Also =
available in=20
      these alternative archive formats: <A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/elefunt.jar"><TT>el=
efunt.jar</TT>,=20
      </A><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/elefunt.zip"><TT>el=
efunt.zip</TT>,=20
      </A>and <A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/elefunt.zoo"><TT>el=
efunt.zoo</TT>.=20
      </A></TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/eps2.c"><TT>eps2.c<=
/TT>=20
      </A></TD>
    <TD>Fortran <TT>REAL</TT> function implemented in C to compute the=20
      generalized machine epsilon. This implementation works by fast =
low-level=20
      bit manipulation. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/eps.f"><TT>eps.f</T=
T>=20
      </A></TD>
    <TD>Fortran <TT>REAL</TT> function <TT>eps(x)</TT> to compute the=20
      generalized machine epsilon. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/epsiter.c"><TT>epsi=
ter.c</TT>=20
      </A></TD>
    <TD>Fortran <TT>REAL</TT> function implemented in C to compute the=20
      generalized machine epsilon. This implementation works by looping. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/fpinfo.f"><TT>fpinf=
o.f</TT>=20
      </A></TD>
    <TD>Fortran program to report the size of single-, double-, and=20
      quadruple-precision datatypes, the floating-point precision in =
bits, and=20
      the corresponding machine epsilon and smallest floating-point =
numbers for=20
      each. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/fpinfosd.f"><TT>fpi=
nfosd.f</TT>=20
      </A></TD>
    <TD>Fortran program to report the size of single- and =
double-precision=20
      datatypes, the floating-point precision in bits, and the =
corresponding=20
      machine epsilon and smallest floating-point numbers for each. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/fpinfo2.c"><TT>fpin=
fo2.c</TT>=20
      </A></TD>
    <TD>C program to report the size of single-, double-, and=20
      quadruple-precision datatypes, the floating-point precision in =
bits, and=20
      the corresponding machine epsilon and smallest floating-point =
numbers for=20
      each. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/fpshow.c"><TT>fpsho=
w.c</TT>=20
      </A></TD>
    <TD>C program to print a number of important constants in decimal =
and=20
      hexadecimal to check internal representations on a new machine. =
</TD></TR>
  <TR>
    <TD><A href=3D"http://www.math.utah.edu/pub/hoc/"><TT>hoc</TT> =
</A></TD>
    <TD>This is a significant extension of the Kernighan &amp; Pike =
high-order=20
      calculator, hoc, with rich support for floating-point arithmetic. =
<IMG=20
      src=3D"http://www.math.utah.edu/images/new2.gif"> </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/ieeeftn.h"><TT>ieee=
ftn.h</TT>=20
      </A></TD>
    <TD>C header file to support interfacing floating-point utility =
access=20
      from Fortran to C. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/infnani.f"><TT>infn=
ani.f</TT>=20
      </A></TD>
    <TD>Fortran program to compute and display hexadecimal values of =
signed=20
      NaN and Infinity, and to display hexadecimal and decimal results =
of their=20
      conversion to integer values. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/intxp.c"><TT>intxp.=
c</TT>=20
      </A></TD>
    <TD>Fortran <TT>INTEGER</TT> function <TT>intxp(x)</TT> implemented =
in C=20
      to return the exponent of the base in the representation of =
<TT>REAL</TT>=20
      <TT>x</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/isden.c"><TT>isden.=
c</TT>=20
      </A></TD>
    <TD>Fortran <TT>LOGICAL</TT> function <TT>isden(x)</TT> implemented =
in C=20
      to return <TT>.TRUE.</TT> if <TT>REAL</TT> <TT>x</TT> is subnormal =

      (formerly, denormalized), and <TT>.FALSE.</TT> otherwise. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/isinf.c"><TT>isinf.=
c</TT>=20
      </A></TD>
    <TD>Fortran <TT>LOGICAL</TT> function <TT>isinf(x)</TT> implemented =
in C=20
      to return <TT>.TRUE.</TT> if <TT>REAL</TT> <TT>x</TT> is infinite, =
and=20
      <TT>.FALSE.</TT> otherwise. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/isnan.c"><TT>isnan.=
c</TT>=20
      </A></TD>
    <TD>Fortran <TT>LOGICAL</TT> function <TT>isnan(x)</TT> implemented =
in C=20
      to return <TT>.TRUE.</TT> if <TT>REAL</TT> <TT>x</TT> is a NaN, =
and=20
      <TT>.FALSE.</TT> otherwise. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/lstohtml.awk"><TT>l=
stohtml.awk</TT>=20
      </A></TD>
    <TD>awk program to convert a UNIX directory listing to HTML (used by =
the=20
      <TT>Makefile</TT> below). </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/machar.f"><TT>macha=
r.f</TT>=20
      </A></TD>
    <TD>Fortran subroutine to determine the characteristics of the host=20
      <TT>REAL</TT> floating-point system. [This program was written by =
W. J.=20
      Cody, Jr., as part of the ELEFUNT test package.] </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/Makefile"><TT>Makef=
ile</TT>=20
      </A></TD>
    <TD>UNIX/POSIX/GNU Makefile to manage building, testing, and =
installing=20
      with the GNU standard procedure: <TT>./configure &amp;&amp; make =
all check=20
      install</TT>. All GNU standard <TT>make</TT> targets are =
supported, so to=20
      reduce the directory to its original distribution status, do =
<TT>make=20
      distclean</TT>. The <TT>install</TT> target is a dummy; there is =
nothing=20
      to install on the local system. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/minmax.f"><TT>minma=
x.f</TT>=20
      </A></TD>
    <TD>Fortran program to test the handling of IEEE 754 NaN by the=20
      <TT>min()</TT> and <TT>max()</TT> intrinsic functions. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/minmax.sh"><TT>minm=
ax.sh</TT>=20
      </A></TD>
    <TD>UNIX/POSIX/GNU shell script to compile and run <TT>minmax.f</TT> =
with=20
      all known Fortran compilers on the current system. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/minmax.txt"><TT>min=
max.txt</TT>=20
      </A></TD>
    <TD>Email message to one of the IEEE 754 committee members with test =

      results for the <TT>minmax.f</TT> program with 61 compilers on 15=20
      different UNIX platforms. The results are consistently dismal: =
<EM>not=20
      one</EM> of them handles NaN arguments in the expected way. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/mmsqrt.f"><TT>mmsqr=
t.f</TT>=20
      </A></TD>
    <TD>Fortran <TT>REAL</TT> square root function implemented using the =

      Moler/Morrison cubically-convergent iterative algorithm. This is=20
      <TT>not</TT> a good algorithm for small <TT>x</TT>; see the code's =
header=20
      comments. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/mpieee.maple"><TT>m=
pieee.maple</TT>=20
      </A></TD>
    <TD>Program to convert floating-point numbers in decimal to =
IEEE-754-like=20
      binary formats, and display them in hexadecimal and decimal. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/mpieee-test.maple">=
<TT>mpieee-test.maple</TT>=20
      </A></TD>
    <TD>Program to use <TT>mpieee.maple</TT> to compute particular =
limits in=20
      IEEE 754 floating-point arithmetic. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/mpieee-test.out"><T=
T>mpieee-test.out</TT>=20
      </A></TD>
    <TD>Test output from <A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/mpieee-test.maple">=
<TT>mpieee-test.maple</TT>.=20
      </A></TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/nxtaft.f"><TT>nxtaf=
t.f</TT>=20
      </A></TD>
    <TD>Fortran <TT>REAL</TT> function <TT>nxtaft(x,y)</TT> to return =
the next=20
      floating-point number after <TT>x</TT> in the direction of =
<TT>y</TT>.=20
      This version uses slow iteration instead of fast bit manipulation. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/ofl.c"><TT>ofl.c</T=
T>=20
      </A></TD>
    <TD>C program to test which floating-point exceptions are raised =
during=20
      floating-point multiply and multiply-add for 0 and Infinity =
operands.=20
  </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/ofl.sh"><TT>ofl.sh<=
/TT>=20
      </A></TD>
    <TD>UNIX/POSIX/GNU shell script to compile and run <TT>ofl.c</TT> =
with a C=20
      compiler defined by the <TT>CC</TT> environment variable. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/ofl-all.sh"><TT>ofl=
-all.sh</TT>=20
      </A></TD>
    <TD>UNIX/POSIX/GNU shell script to compile and run <TT>ofl.c</TT> =
with all=20
      known C compilers. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/ofl-all.txt"><TT>of=
l-all.txt</TT>=20
      </A></TD>
    <TD>Test results from <TT>ofl-all.sh</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/paranoia.c"><TT>par=
anoia.c</TT>=20
      </A></TD>
    <TD>C program to carry out a torture test on the host system's=20
      floating-point arithmetic. [This program is credited to W. M. =
Kahan, B. A.=20
      Wichmann, David M. Gay, Thos Sumner, and Richard Karpinski. It has =
been=20
      extended by NHFB to permit compilation under Standard C and =
Standard C++.]=20
      Versions of this program in other languages are available in the =
<A=20
      href=3D"http://www.netlib.org/paranoia/">Netlib archive. </A>[That =
archive=20
      contains a few bug fixes to this program which have not yet been=20
      incorporated in the version here.] </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/paranoia.h"><TT>par=
anoia.h</TT>=20
      </A></TD>
    <TD>Header file for <TT>paranoia.c</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/qtest.f"><TT>qtest.=
f</TT>=20
      </A></TD>
    <TD>Fortran floating-point accuracy test program. [This program was=20
      written by W. M. Kahan.] </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/ran.f"><TT>ran.f</T=
T>=20
      </A></TD>
    <TD>Fortran <TT>REAL</TT> function to return a pseudo-random number=20
      uniformly distributed on (0,1). [This program was written by W. J. =
Cody,=20
      Jr., as part of the ELEFUNT test package.] </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/randl.f"><TT>randl.=
f</TT>=20
      </A></TD>
    <TD>Fortran <TT>REAL</TT> function to return a pseudo-random number=20
      logarithmically distributed on (1,<TT>exp(x)</TT>). [This program =
was=20
      written by W. J. Cody, Jr., as part of the ELEFUNT test package.] =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/README.NaN"><TT>REA=
DME.NaN</TT>=20
      </A></TD>
    <TD>Brief summary of findings about the representation of NaN on =
various=20
      platforms. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/round-trip-problems=
.c"><TT>round-trip-problems.c</TT>=20
      </A></TD>
    <TD>C program to find single-precision test numbers that are hard to =

      convert from binary to decimal and back accurately. [This program =
was=20
      written by David Goldberg =
<TT>&lt;goldberg@parc.xerox.com&gt;</TT>.]=20
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/rwfp.f"><TT>rwfp.f<=
/TT>=20
      </A></TD>
    <TD>Fortran program to read floating-point numbers, and display them =
as=20
      single-, double-, and quadruple-precision values in hexadecimal =
and=20
      decimal. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/rwfp2a.c"><TT>rwfp2=
a.c</TT>=20
      </A></TD>
    <TD>C program to read floating-point numbers, and display them as =
single-,=20
      double-, and quadruple-precision values in hexadecimal and =
decimal,=20
      assuming <TT>printf()</TT> supports a <TT>%Le</TT> format item. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/rwfp2b.c"><TT>rwfp2=
b.c</TT>=20
      </A></TD>
    <TD>C program to read floating-point numbers, and display them as =
single-,=20
      double-, and quadruple-precision values in hexadecimal and =
decimal,=20
      assuming <TT>printf()</TT> supports a <TT>%lle</TT> format item. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/rwinfnan1.f"><TT>rw=
infnan1.f</TT>=20
      </A></TD>
    <TD>Fortran program to test whether Infinity and NaN can be output =
to a=20
      text file, and then input correctly. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/rwinfnan1.txt"><TT>=
rwinfnan1.txt</TT>=20
      </A></TD>
    <TD>Test results for <TT>rwinfnan1.f</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/rwinfnan2.c"><TT>rw=
infnan2.c</TT>=20
      </A></TD>
    <TD>C program to test whether Infinity and NaN can be output to a =
text=20
      file, and then input correctly. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/rwinfnan2.txt"><TT>=
rwinfnan2.txt</TT>=20
      </A></TD>
    <TD>Test results for <TT>rwinfnan2.c</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/rwinfnan3.cc"><TT>r=
winfnan3.cc</TT>=20
      </A></TD>
    <TD>C++ program to test whether Infinity and NaN can be output to a =
text=20
      file, and then input correctly. Because of variations in names and =

      locations of C++ header files at different language development =
stages, it=20
      is unlikely that this program can be successfully compiled by any =
C++=20
      compiler, other than GNU <TT>g++</TT>. Work remains to be done on=20
      developing suitable wrappers to hide this header file mess, and =
make it=20
      easier to write portable C++ programs. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/rwinfnan3.txt"><TT>=
rwinfnan3.txt</TT>=20
      </A></TD>
    <TD>Test results for <TT>rwinfnan3.cc</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/rwinfnanascii.java"=
><TT>rwinfnanascii.java</TT>=20
      </A></TD>
    <TD>Java program to investigate whether Infinity and NaN can be =
generated=20
      and successfully written to, and read from, a text file. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/rwinfnanbinary.java=
"><TT>rwinfnanbinary.java</TT>=20
      </A></TD>
    <TD>Java program to investigate whether Infinity and NaN can be =
generated=20
      and successfully written to, and read from, a binary file. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/second.c"><TT>secon=
d.c</TT>=20
      </A></TD>
    <TD>Fortran <TT>DOUBLE PRECISION</TT> function implemented in C to =
return=20
      the CPU time in seconds since job start. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/setxp.c"><TT>setxp.=
c</TT>=20
      </A></TD>
    <TD>Fortran <TT>REAL</TT> function <TT>setxp(x,n)</TT> implemented =
in C to=20
      return <TT>(fraction of x) * base**n</TT>, that is, to replace the =

      exponent field of a copy of <TT>x</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/signchar.c"><TT>sig=
nchar.c</TT>=20
      </A></TD>
    <TD>C program to report on characteristics of the <TT>char</TT> data =
type.=20
    </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/signchar.sh"><TT>si=
gnchar.sh</TT>=20
      </A></TD>
    <TD>UNIX/POSIX/GNU shell script to compile and run =
<TT>signchar.c</TT>=20
      with a C compiler defined by the <TT>CC</TT> environment variable. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/signchar-all.sh"><T=
T>signchar-all.sh</TT>=20
      </A></TD>
    <TD>UNIX/POSIX/GNU shell script to compile and run =
<TT>signchar.c</TT>=20
      with all known C compilers. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/signchar-all.txt"><=
TT>signchar-all.txt</TT>=20
      </A></TD>
    <TD>Test results from <TT>signchar-all.sh</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/signchar-lcc.sh"><T=
T>signchar-lcc.sh</TT>=20
      </A></TD>
    <TD>UNIX/POSIX/GNU shell script to compile and run =
<TT>signchar.c</TT>=20
      with the <TT>lcc</TT> C compiler. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/sqrt.f"><TT>sqrt.f<=
/TT>=20
      </A></TD>
    <TD>Fortran <TT>REAL</TT> square root function. This was written for =
an=20
      introductory class on scientific programming to show how one =
Fortran=20
      elementary function can be implemented; see below for =
documentation.=20
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/sqrt.pdf"><TT>sqrt.=
pdf</TT>=20
      </A></TD>
    <TD>Documentation for <TT>dsqrt.f</TT>, <TT>dssqrt.f</TT>, and=20
      <TT>sqrt.f</TT> (see above), in PDF format. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/sqrt.ps.gz"><TT>sqr=
t.ps.gz</TT>=20
      </A></TD>
    <TD>Documentation for <TT>dsqrt.f</TT>, <TT>dssqrt.f</TT>, and=20
      <TT>sqrt.f</TT> (see above), in PostScript format. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/subnorm.f"><TT>subn=
orm.f</TT>=20
      </A></TD>
    <TD>Fortran program to test whether the smallest representable =
single-,=20
      double-, and quadruple-precision floating-point numbers are =
normalized, or=20
      <EM>subnormal</EM> (formerly called <EM>denormalized</EM>). =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/subnorm2.f"><TT>sub=
norm2.f</TT>=20
      </A></TD>
    <TD>Fortran program to test whether the smallest representable =
single- and=20
      double-precision floating-point numbers are normalized, or=20
      <EM>subnormal</EM> (formerly called <EM>denormalized</EM>). =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/tanh.pdf"><TT>tanh.=
pdf</TT>=20
      </A></TD>
    <TD>Documentation for <TT>dtanh.f</TT> (see above), in PDF format. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/tanh.ps.gz"><TT>tan=
h.ps.gz</TT>=20
      </A></TD>
    <TD>Documentation for <TT>dtanh.f</TT> (see above), in PostScript =
format.=20
    </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/tdsqrt1.f"><TT>tdsq=
rt1.f</TT>=20
      </A></TD>
    <TD>Fortran program to test the accuracy of the native =
<TT>dsqrt(x)</TT>=20
      function. [This program was written by W. J. Cody, Jr. and W. =
Waite as=20
      part of the ELEFUNT test package.] </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/tdsqrt2.f"><TT>tdsq=
rt2.f</TT>=20
      </A></TD>
    <TD>Fortran program to test the accuracy of a private =
<TT>dsqrt(x)</TT>=20
      function. [This program was written by W. J. Cody, Jr. and W. =
Waite as=20
      part of the ELEFUNT test package.] </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/test-gradual-underf=
low.c"><TT>test-gradual-underflow.c</TT>=20
      </A></TD>
    <TD>C program to test the speed of handling gradual underflow. [This =

      program was written by Vaughan Pratt=20
      <TT>&lt;pratt@cs.stanford.edu&gt;</TT>.] </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/testdp.c"><TT>testd=
p.c</TT>=20
      </A></TD>
    <TD>C program to test the Fortran <TT>DOUBLE PRECISION</TT> support=20
      functions. This program needs several of the other files listed in =
this=20
      table, and takes a long time to run (from several minutes to a few =
hours=20
      on early 1990s-vintage workstations). </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/testsp.c"><TT>tests=
p.c</TT>=20
      </A></TD>
    <TD>C program to test the Fortran <TT>REAL</TT> support functions. =
This=20
      program needs several of the other files listed in this table, and =
takes a=20
      long time to run (from several minutes to a few hours on early=20
      1990s-vintage workstations). </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/timdep.c"><TT>timde=
p.c</TT>=20
      </A></TD>
    <TD>C program to run timing tests for the Fortran <TT>deps(x)</TT>=20
      generalized machine epsilon function. This program needs several =
of the=20
      other files listed in this table. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/timops.html"><TT>ti=
mops</TT>=20
      </A></TD>
    <TD>Benchmark report on the cost of IEEE 754 exceptional values for =
a wide=20
      range of architectures. All of the code, and the raw and summary =
results,=20
      are available from that document. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/timeps.c"><TT>timep=
s.c</TT>=20
      </A></TD>
    <TD>C program to run timing tests for the Fortran <TT>eps(x)</TT>=20
      generalized machine epsilon function. This program needs several =
of the=20
      other files listed in this table. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/timtst.c"><TT>timts=
t.c</TT>=20
      </A></TD>
    <TD>C program to run timing tests of the Fortran floating-point=20
      primitives. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/tsqrt1.f"><TT>tsqrt=
1.f</TT>=20
      </A></TD>
    <TD>Fortran program to test the accuracy of the native =
<TT>sqrt(x)</TT>=20
      function. [This program was written by W. J. Cody, Jr. and W. =
Waite as=20
      part of the ELEFUNT test package.] </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/tsqrt2.f"><TT>tsqrt=
2.f</TT>=20
      </A></TD>
    <TD>Fortran program to test the accuracy of a private =
<TT>sqrt(x)</TT>=20
      function. [This program was written by W. J. Cody, Jr. and W. =
Waite as=20
      part of the ELEFUNT test package.] </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/tstchr.c"><TT>tstch=
r.c</TT>=20
      </A></TD>
    <TD>C program to print the return values of the Standard C isxxx()=20
      character classifier functions for every character in the =
256-character=20
      set. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/tstdep.c"><TT>tstde=
p.c</TT>=20
      </A></TD>
    <TD>Another C program to test the Fortran <TT>DOUBLE PRECISION</TT>=20
      support functions. This program needs several of the other files =
listed in=20
      this table, and takes a long time to run (from several minutes to =
a few=20
      hours on early 1990s-vintage workstations). </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/tsteps.c"><TT>tstep=
s.c</TT>=20
      </A></TD>
    <TD>Another C program to test the Fortran <TT>REAL</TT> support =
functions.=20
      This program needs several of the other files listed in this =
table, and=20
      takes a long time to run (from several minutes to a few hours on =
early=20
      1990s-vintage workstations). </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/wchar.awk"><TT>wcha=
r.awk</TT>=20
      </A></TD>
    <TD>awk program to summarize the output of <TT>wchar.sh</TT>. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/wchar.c"><TT>wchar.=
c</TT>=20
      </A></TD>
    <TD>C program to report characteristics of wide character=20
      (<TT>wchar_t</TT>) support. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/wchar.sh"><TT>wchar=
.sh</TT>=20
      </A></TD>
    <TD>UNIX/POSIX/GNU shell script to compile and run <TT>wchar.c</TT> =
with a=20
      C compiler defined by the <TT>CC</TT> environment variable. =
</TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/wchar-all.sh"><TT>w=
char-all.sh</TT>=20
      </A></TD>
    <TD>UNIX/POSIX/GNU shell script to compile and run <TT>wchar.c</TT> =
with=20
      all known C compilers. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/wchar-all.txt"><TT>=
wchar-all.txt</TT>=20
      </A></TD>
    <TD>Test results from <TT>wchar-all.sh</TT>. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/wchar-lcc.sh"><TT>w=
char-lcc.sh</TT>=20
      </A></TD>
    <TD>UNIX/POSIX/GNU shell script to compile and run <TT>wchar.c</TT> =
with=20
      the <TT>lcc</TT> C compiler. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/zerocomp.c"><TT>zer=
ocomp.c</TT>=20
      </A></TD>
    <TD>C program to test whether oppositedly-signed zeros are correctly =

      compared. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/zerosdqb.f"><TT>zer=
osdqb.f</TT>=20
      </A></TD>
    <TD>Fortran program to test whether IEEE 754 signed zero is =
supported in=20
      single, double and quadruple precision. This version needs a =
nonstandard=20
      <TT>BYTE</TT> data type. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/zerosdqi.f"><TT>zer=
osdqi.f</TT>=20
      </A></TD>
    <TD>Fortran program to test whether IEEE 754 signed zero is =
supported in=20
      single, double and quadruple precision. This version needs a =
nonstandard=20
      <TT>INTEGER*1</TT> data type. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/zerosdb.f"><TT>zero=
sdb.f</TT>=20
      </A></TD>
    <TD>Fortran program to test whether IEEE 754 signed zero is =
supported in=20
      single and double precision. This version needs a nonstandard=20
      <TT>BYTE</TT> data type. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/zerosdi.f"><TT>zero=
sdi.f</TT>=20
      </A></TD>
    <TD>Fortran program to test whether IEEE 754 signed zero is =
supported in=20
      single and double precision. This version needs a nonstandard=20
      <TT>INTEGER*1</TT> data type. </TD></TR>
  <TR>
    <TD><A=20
      =
href=3D"http://www.math.utah.edu/~beebe/software/ieee/zerosdq.c"><TT>zero=
sdq.c</TT>=20
      </A></TD>
    <TD>C program to test whether IEEE 754 signed zero is supported in =
single,=20
      double and quadruple precision. =
</TD></TR></TBODY></TABLE><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dfutures>Future directions </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#catalog">Previous =

</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#other">Next=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>This collection certainly needs to be augmented with additional =
software to=20
test other features of the implementation of floating-point tests. </P>
<P>While many of the programs here are simply test programs, there are =
several=20
that are intended to provide platform-independent access to features of =
the=20
underlying floating-point system. Most of these have names that were =
recommended=20
either by the <A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/fparith.html#IEEE:1985:AIS">=
1985 IEEE=20
754 Standard, </A>or by Cody and Waite in their book. </P>
<P>I would ultimately like to extend this collection to include =
well-documented,=20
well-tested, and highly-portable implementations of <EM>all</EM> of the=20
floating-point primitives recommended by the IEEE 754 standard, both the =

original one, and its eventual revision, together with equally portable =
test=20
packages to verify their correct functioning on any platform. </P>
<P>These primitives ultimately need to be available for all major =
programming=20
languages, which certainly includes Fortran, C, C++, Java, and Common =
Lisp, but=20
also symbolic algebra languages like Axiom, Maple, Mathematica, and =
Reduce,=20
linear algebra systems like Matlab and Octave, statistical languages =
like S-Plus=20
and R, and scripting languages like awk, icon, guile, perl, python, =
rexx, ruby,=20
tcl, ... The key to this is certainly to first get them available for C, =
because=20
most of the other current programming languages can interface to C, or =
can be=20
extended to do so. =
</P><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dother>Other test packages </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#futures">Previous =

</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#bibliography">Next=
=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>The University of California at Berkeley floating-point test suite,=20
<TT>ucbtest</TT> (later extended at Sun Microsystems) is available in =
the Netlib=20
archives at <A=20
href=3D"http://www.netlib.org/fp/ucbtest.tgz">http://www.netlib.org/fp/uc=
btest.tgz</A></P>
<P>The IEEE 754 Compliance Checker, IeeeCC754, is available at <A=20
href=3D"http://win-www.uia.ac.be/u/cant/ieeecc754.html">http://win-www.ui=
a.ac.be/u/cant/ieeecc754.html</A>From=20
its Web site: ``... is a precision and range independent tool to test =
whether an=20
implementation of floating-point arithmetic (in hardware or software) is =

compliant with the principles of the IEEE floating-point standard.'' =
</P>
<P>The C/C++ compiler <A =
href=3D"http://www.math.utah.edu/pub/features/">feature=20
test package </A><IMG src=3D"http://www.math.utah.edu/images/new2.gif"> =
can be=20
used to report what features of the 1989 and 1999 ISO C Standard, and =
the 1998=20
ISO C++ Standard, are supported by your compiler. From version 1.1, it =
includes=20
some tests of basic IEEE 754 arithmetic, but does not exercise any of =
the=20
floating-point elementary functions in the runtime library. </P>
<P>The Cody/Waite <A =
href=3D"http://www.math.utah.edu/pub/elefunt/">ELEFUNT=20
elementary function test package </A>in Fortran, C/C++, and Java. =
</P><!--=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D-->
<HR>

<H1><A name=3Dbibliography>Bibliography </A></H1><SMALL><A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#other">Previous=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#toc">First=20
</A>&nbsp;&nbsp;&nbsp; <A=20
href=3D"http://www.math.utah.edu/~beebe/software/ieee/#top">Up =
</A></SMALL>
<P>I maintain an <A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/index-table-f.html#fparith">=
extensive=20
bibliography </A>of publications about floating-point arithmetic, =
carrying on=20
work started by Norbert Juffa. The material is also available at=20
<TT>ftp://ftp.math.utah.edu/pub/tex/bib/fparith.*</TT>. </P>
<P>Notable recent books listed there with an emphasis on computer =
arithmetic and=20
computation of elementary functions include those with citation labels =
<A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/fparith.html#Higham:1996:ASN=
"><B>Higham:1996:ASN</B>=20
</A>(<EM>Accuracy and Stability of Numerical Algorithms</EM>), <A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/fparith.html#Markstein:2000:=
IEF"><B>Markstein:2000:IEF</B>=20
</A>(<EM>IA-64 and elementary functions: speed and precision</EM>), <A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/fparith.html#"><B>Moshier:19=
89:MPM</B>=20
</A>(<EM>Methods and Programs for Mathematical Functions</EM>), <A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/fparith.html#Mueller:2000:CA=
C"><B>Mueller:2000:CAC</B>=20
</A>(<EM>Computer Architecture: Complexity and Correctness</EM>), <A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/fparith.html#Omondi:1994:CAS=
"><B>Omondi:1994:CAS</B>=20
</A>(<EM>Computer Arithmetic Systems: Algorithms, Architecture, and=20
Implementation</EM>), <A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/fparith.html#Overton:2001:NC=
I"><B>Overton:2001:NCI</B>=20
</A>(<EM>Numerical Computing with IEEE Floating Point Arithmetic, =
Including One=20
Theorem, One Rule of Thumb, and One Hundred and One Exercises</EM>), and =
<A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/fparith.html#Parhami:2000:CA=
A"><B>Parhami:2000:CAA</B>=20
</A>(<EM>Computer Arithmetic: Algorithms and Hardware Designs</EM>). =
These are=20
all well-written books that are worth reading. Markstein's book is is =
the first=20
to address the question of accurate floating-point computation on the =
new=20
Hewlett-Packard/Intel IA-64 architecture, which is covered in a <A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/index-table-i.html#intel-ia-=
64">separate=20
bibliography, </A>also available at=20
<TT>ftp://ftp.math.utah.edu/pub/tex/bib/intel-ia-64.*</TT>. </P>
<P><A name=3Dschryer-report>Norman Schryer's report </A><A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/fparith.html#Schryer:1981:TC=
F"><B>[Schryer:1981:TCF]</B>=20
</A>describes a very large (ca. 30K lines of portable Fortran 77 code) =
test=20
package, <TT>FPTEST</TT>, for floating-point arithmetic that was =
developed prior=20
to IEEE 754 arithmetic, but has been used subsequently to test systems =
with that=20
arithmetic. The package is not freely distributable, but is available =
under=20
license from <A href=3D"http://www.bell-labs.com/project/fptest/">Bell=20
Laboratories. </A>Unfortunately, the <TT>FPTEST</TT> distribution is =
missing a=20
major part of the test suite; I'm investigating this further. </P>
<P>Schryer's report makes very interesting reading, and details quite a =
number=20
of unexpected and bizarre failures of arithmetic, including several =
where=20
floating-point results were time dependent on the same machine! </P>
<P>The father of IEEE 754 arithmetic, <A name=3Dkahan-java-hurt>W. =
Kahan, </A>with=20
co-author J. D. Darcy, is severely critical of Java's floating-point =
arithmetic=20
in <A=20
href=3D"http://www.math.utah.edu/pub/tex/bib/fparith.html#Kahan:1998:HJFa=
"><B>Kahan:1998:HJFa</B>=20
and <B>Kahan:1998:HJFb</B>, </A>in the article <EM>How Java's =
Floating-Point=20
Hurts Everyone Everywhere.</EM> </P>
<P>Charles Severance and W. Kahan have written an interesting document =
on the=20
history of the development of IEEE 754 arithmetic, available at <A=20
href=3D"http://www.cs.berkeley.edu/~wkahan/ieee754status/754story.html">h=
ttp://www.cs.berkeley.edu/~wkahan/ieee754status/754story.html</A></P></BO=
DY></HTML>

------=_NextPart_000_00DE_01CBE1BC.CC243FA0
Content-Type: image/gif
Content-Transfer-Encoding: base64
Content-Location: http://www.math.utah.edu/images/new2.gif

R0lGODlhIAAQAKEAAAAAAP//AL+/vwAAACH5BAEAAAIALAAAAAAgABAAAAJhlI+AK8oM4gHByVmT
SyFT31ld1pDL94VjlYbo067yPG6QqkZRtb5QuuO1hrWTjIJkoVi8oqbmarp0KBtHmuzhrFescomF
0cZkbvU4JJoMSFGI/S6B1heMrV6y4B8NfoJfAAA7

------=_NextPart_000_00DE_01CBE1BC.CC243FA0--
